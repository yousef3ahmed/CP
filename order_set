// only in less_equal lower_bound work such as upper_bound;
// by *find_by_order given index --> val ;
// by order_of_key given  value --> index ;
// erase and insert in log(n) ;
// used norm policy data strc when no dublcate the same element; 


#include <ext/pb_ds/assoc_container.hpp> // Common file
#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update
using namespace __gnu_pbds;
template<class T> using ordered_set = tree<T, null_type , less_equal<T> , rb_tree_tag , tree_order_statistics_node_update> ;
 
struct ordered__set{
	ordered_set< ll > se ;
 
	int CntLesOrEqual( ll val ){
		int sz = se.size() ;
		if( se.size() == 0 || *se.find_by_order( 0 ) > val ) return 0 ;
		if( *se.find_by_order( sz - 1 ) <= val ) return sz;  
		return se.order_of_key( *se.lower_bound( val ) ) ;
	}
 
	int CntLes( ll val ){	
		int sz = se.size() ;
		if( se.size() == 0 || *se.find_by_order( 0 ) >= val ) return 0 ;
		if( *se.find_by_order( sz - 1 ) < val ) return sz;  
		return se.order_of_key( *se.lower_bound( --val ) ) ;
	}
 
 
	// include ;
	int range( ll left , ll right  ){
		return CntLesOrEqual( right ) - CntLes( left ) ;
	}

	int find( ll val ){ // check is element exsit or not ;
		return range( val , val ) ;
	}
 
	void erase( ll val ){ // log ;
		if( !find( val ) ) return ;
		se.erase( se.lower_bound( --val ) ) ;
	}
 
	int lw( ll val ){ // log --> return val ;
		if( CntLes( val ) == se.size() ) return -1 ;
		return *se.lower_bound( --val ) ;
	}
 
	void insert( ll val ){ // log ;
		se.insert( val );
	}
 
	
    ll operator[](int idx) {
        return *se.find_by_order( idx ) ;
    }
 
	int size( ){
		return se.size();
	}
 
	void clr(  ){
		se.clear() ;
	}
 
}myset;	